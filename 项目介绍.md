# JavaScript 编译器项目指南

> **项目名称**: js_compiler_by_c  
> **最后更新**: 2025 年 12 月 2 日  
> **定位**: 覆盖 ECMAScript 5.1 及主流 ES2015+/ES2017 语法的 C 语言 JavaScript 语法前端

---

## 目录

[toc]

---

## 项目概述

### 项目定位

`js_compiler_by_c` 使用 C 语言实现，包含词法分析、语法分析、AST 生成与自动分号插入（ASI）四个层面。现阶段目标是“脚本/模块语法校验 + AST 输出”，已覆盖 ES5.1 以及 ES2015/ES2017 的主流语法（模块、类、解构、默认参数、`...rest/spread`、模板字符串、`function*`/`yield*`、`for-of`、箭头函数、`async`/`await` 等），可用于批量校验 `test/JavaScript_Datasets` 中的压缩脚本。

### 核心特性

- **词法分析器** (`js_lexer.exe`)

  - 识别 ES5 + ES2015+ 关键字（`class/extends/super`、`import/export`、`async/await`、`yield` 等）以及模板字符串片段、BigInt、私有字段、`...`、`=>` 等复合符号
  - 提供正则/除法判定所需的 `PrevTokenState`，维持 `has_newline`、括号深度与模板状态，方便 ASI 与正则字面量解析
  - 支持十进制/二进制/八进制/十六进制数字、科学计数法、字符串、模板、正则、布尔、`null` 等所有常用字面量

- **语法分析器** (`js_parser.exe`)

  - 覆盖 Script/Module、`import`/`export`、类与增强对象字面量、解构绑定、`function*`/`yield*`、`async function`/`await`、箭头函数、模板字符串、`for-of`、`new` 调用链、标签语句等
  - `_no_obj` / `_no_in` / `_no_arr` 变体配合 `ARROW_HEAD`、`FUNCTION_DECL`、`member_call_expr` 等辅助产生式，解决块/对象、`for-in`、多行箭头与 IIFE 的歧义
  - 所有语义动作直接构建 AST，可通过 `--dump-ast` 或 `build/parser_error_locations.log` 快速定位问题

- **自动分号插入 (ASI)**

  - 遵循 ECMA-262 11.9，并针对 `catch` 头、`new` + IIFE、`new` 调用链、`?: { ... }`、`yield`/`await`、模板字符串、`ARROW_HEAD` 等场景追加保护逻辑
  - `parser_lex_adapter.c` 维护控制语句栈、括号栈和三元深度，必要时插入虚拟 `';'` 并延迟回放真实 token

- **AST 框架**
  - 90+ 节点涵盖程序/模块、导入导出、类、方法、生成器、箭头函数、模板、解构、`for-of`、spread/rest、标签、错误处理等
  - `ast_print` + `ast_traverse`/`ast_free` 统一管理构造、调试、遍历与释放，便于在 `JavaScript_Datasets` 批量运行

### 技术栈

| 组件       | 技术选型     | 版本要求 |
| ---------- | ------------ | -------- |
| 词法生成器 | re2c         | ≥ 3.0    |
| 语法生成器 | GNU Bison    | ≥ 3.0    |
| 编译器     | GCC (MinGW)  | ≥ 7.0    |
| 构建工具   | Make / Batch | -        |
| 编程语言   | C            | -        |

---

---

## 快速开始

### 克隆项目

```bash
git clone https://github.com/Stardreama/js_compiler_by_c.git
cd js_compiler_by_c
```

### Windows 用户

#### 方式一：使用 make（推荐）

```powershell
# 1. 构建词法分析器
.\make

# 2. 测试词法分析器
.\js_lexer.exe test\test_basic.js

# 3. 构建语法分析器
.\make parser

# 4. 测试语法分析器
.\js_parser.exe test\test_basic.js

# 5. 查看 AST 输出
.\js_parser.exe --dump-ast test\test_basic.js

# 6. 运行完整测试套件
.\make test-parse
```

#### 方式二：使用 MSYS2 终端

```bash
cd /d/EduLibrary/OurEDA/js_compiler_by_c
make parser
./js_parser.exe test/test_basic.js
```

### Linux / macOS 用户

```bash
# 1. 构建语法分析器
make parser

# 2. 测试
./js_parser.exe test/test_basic.js

# 3. 查看 AST
./js_parser.exe --dump-ast test/test_basic.js

# 4. 运行完整测试
make test-parse
```

### 构建命令速查表

| 命令                | 功能                   | 适用平台    |
| ------------------- | ---------------------- | ----------- |
| `.\make`            | 构建词法分析器         | Windows     |
| `.\make parser`     | 构建语法分析器         | Windows     |
| `.\make test`       | 构建并测试词法分析器   | Windows     |
| `.\make test-parse` | 构建并运行完整测试套件 | Windows     |
| `.\make clean`      | 清理生成文件           | Windows     |
| `.\make help`       | 显示帮助信息           | Windows     |
| `make`              | 构建词法分析器         | Linux/macOS |
| `make parser`       | 构建语法分析器         | Linux/macOS |
| `make test-parse`   | 运行完整测试套件       | Linux/macOS |
| `make clean`        | 清理生成文件           | Linux/macOS |

---

## 核心架构

### 系统架构图

```text
┌─────────────────┐
│  JS 源代码文件  │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────┐
│   词法分析 (lexer.re → lexer.c) │
│   • 识别关键字、运算符、字面量    │
│   • 跟踪行号/列号                │
│   • 标记换行状态 (ASI)           │
└────────┬────────────────────────┘
         │ Token 流
         ▼
┌─────────────────────────────────┐
│   适配层 (parser_lex_adapter.c) │
│   • ASI 自动分号插入决策         │
│   • 控制语句栈管理               │
│   • Token 队列缓冲               │
└────────┬────────────────────────┘
         │ Bison Token
         ▼
┌─────────────────────────────────┐
│   语法分析 (parser.y → parser.c)│
│   • 语法规则匹配                 │
│   • AST 节点构建                 │
│   • 歧义消解                     │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│   AST 管理 (ast.c / ast.h)      │
│   • 节点构造、打印、释放         │
│   • 深度优先遍历                 │
│   • 内存安全保障                 │
└─────────────────────────────────┘
```

### 模块职责划分

| 文件                    | 职责                                 | 行数 |
| ----------------------- | ------------------------------------ | ---- |
| `lexer.re`              | re2c 词法规则定义                    | 374  |
| `lexer.c`               | 由 re2c 生成的词法分析器             | 自动 |
| `token.h`               | Token 类型枚举与词法状态结构         | ~100 |
| `parser.y`              | Bison 语法规则与语义动作             | 317  |
| `parser.c` / `parser.h` | 由 Bison 生成的语法分析器            | 自动 |
| `parser_lex_adapter.c`  | 词法-语法桥接 + ASI 实现             | ~400 |
| `ast.c` / `ast.h`       | AST 节点定义、构造、打印、遍历、释放 | ~800 |
| `main.c`                | `js_lexer.exe` 入口（Token dump）    | ~100 |
| `parser_main.c`         | `js_parser.exe` 入口（语法检查+AST） | ~150 |
| `make`                  | Windows 构建脚本                     | ~200 |
| `Makefile`              | MSYS2/Linux 构建脚本                 | ~80  |

### 目录结构

```text
js_compiler_by_c/
├── ast.c / ast.h              # AST 框架
├── make                  # Windows 构建脚本
├── docs/                      # 项目文档
│   ├── BUILD.md               # 构建指南
│   ├── TEST_REPORT.md         # 测试报告
│   ├── asi_implementation.md  # ASI 实现细节
│   ├── parser.md              # 语法分析说明
│   ├── lex.md                 # 词法分析说明
│   └── todo.md                # 开发任务清单
├── lexer.re                   # re2c 词法描述
├── main.c                     # js_lexer.exe 入口
├── Makefile                   # MSYS2/Linux 构建脚本
├── parser.y                   # Bison 语法描述
├── parser_lex_adapter.c       # 词法-语法桥接 + ASI
├── parser_main.c              # js_parser.exe 入口
├── 项目介绍.md                 # 本文档
├── PROJECT_OVERVIEW.md        # 项目说明书
├── readme.md                  # 项目简介
├── test/                     # 测试用例集
│   ├── test_basic.js          # 综合语法测试
│   ├── test_simple.js         # 简单功能测试
│   ├── test_functions.js      # 函数测试
│   ├── test_for_loops.js      # for 循环测试
│   ├── test_literals.js       # 字面量测试
│   ├── test_asi_basic.js      # ASI 基础测试
│   ├── test_asi_return.js     # ASI 受限产生式测试
│   ├── test_asi_control.js    # ASI 控制语句测试
│   ├── test_while.js          # while 循环测试
│   ├── test_switch.js         # switch 语句测试
│   ├── test_try.js            # try-catch-finally 测试
│   ├── test_operators.js      # 运算符测试
│   └── test_error_*.js        # 错误检测测试
└── token.h                    # Token 定义
```

---

## 功能详解

### 词法分析器 (Lexer)

#### 核心功能

**作用**：将 JavaScript 源代码（字符流）转换为 Token 流（词法单元）。

**识别能力**：

- **关键字**（27 个）：var, let, const, function, return, if, else, for, while, do, switch, case, default, break, continue, try, catch, finally, throw, with, typeof, delete, void, new, this, in, instanceof
- **运算符**（73+）：
  - 算术：`+`, `-`, `*`, `/`, `%`, `++`, `--`
  - 比较：`<`, `>`, `<=`, `>=`, `==`, `!=`, `===`, `!==`
  - 逻辑：`&&`, `||`, `!`
  - 位运算：`&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
  - 赋值：`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`
  - 三元：`?`, `:`
  - 其他：`.`, `,`, `;`, `(`, `)`, `{`, `}`, `[`, `]`
- **字面量**：
  - 数字：整数、浮点数、科学计数法（`1e5`）、十六进制（`0xFF`）
  - 字符串：单引号和双引号，支持转义字符（`\n`, `\t`, `\"`, `\'`, `\\`）
  - 布尔值：`true`, `false`
  - 特殊值：`null`, `undefined`

**ES2015+ 扩展**：

- 模板字符串片段（`TEMPLATE_HEAD/MIDDLE/TAIL`）与 tagged template。
- `class/extends/super`、`import/export`、`async/await`、`yield`、`let`/`const` 等关键字。
- BigInt 与二/八进制数字字面量、`...`（spread/rest）、`=>`（箭头）、正则字面量、私有字段、`#`-开头标识符等复合 token。
- 记录 `has_newline`、`PrevTokenState`、花括号/括号深度、模板嵌套状态，方便 ASI 与正则判定。

**示例输出**：

```bash
.\js_lexer.exe test\test_basic.js
```

```text
=== Lexical Analysis of 'test\test_basic.js' ===

[  1] Line   2, Col   1: VAR             = 'var'
[  2] Line   2, Col   5: IDENTIFIER      = 'x'
[  3] Line   2, Col   7: =
[  4] Line   2, Col   9: NUMBER          = '10'
[  5] Line   2, Col  11: ;
...
```

### 语法分析器 (Parser)

#### 核心功能

**作用**：根据 JavaScript 语法规则，将 Token 流组织成抽象语法树（AST），验证代码结构是否合法。

#### 支持的语句

| 语句类型          | 语法示例                                   | AST 节点类型        |
| ----------------- | ------------------------------------------ | ------------------- |
| 变量声明          | `var x = 10;`                              | `AST_VAR_DECL`      |
| 函数声明          | `function foo(a, b) { return a + b; }`     | `AST_FUNCTION`      |
| if-else           | `if (x > 0) { ... } else { ... }`          | `AST_IF_STMT`       |
| for 循环          | `for (var i = 0; i < 10; i++) { ... }`     | `AST_FOR_STMT`      |
| while 循环        | `while (x > 0) { x--; }`                   | `AST_WHILE_STMT`    |
| do-while 循环     | `do { x++; } while (x < 10);`              | `AST_DO_WHILE_STMT` |
| switch-case       | `switch (x) { case 1: break; default: }`   | `AST_SWITCH_STMT`   |
| try-catch-finally | `try { ... } catch (e) { ... } finally {}` | `AST_TRY_STMT`      |
| throw             | `throw new Error("msg");`                  | `AST_THROW_STMT`    |
| with              | `with (obj) { ... }`                       | `AST_WITH_STMT`     |
| 标签语句          | `loop: for (...) { break loop; }`          | `AST_LABELED_STMT`  |
| return            | `return x + y;`                            | `AST_RETURN_STMT`   |
| break/continue    | `break; continue label;`                   | `AST_BREAK_STMT`    |

> 额外 ES2015+ 语句：`import`/`export`、`class` 声明/表达式、`function*`/`yield`、`for-of`、`async function`/`await`、`try`/`catch` 解构绑定、`with`、标签语句等均已实现，对应 AST 节点可参考 `ast.h`。

#### 支持的表达式

| 表达式类型 | 语法示例                        | AST 节点类型           |
| ---------- | ------------------------------- | ---------------------- |
| 字面量     | `42`, `"hello"`, `true`, `null` | `AST_LITERAL`          |
| 标识符     | `foo`, `_bar`, `$baz`           | `AST_IDENTIFIER`       |
| 二元运算   | `a + b`, `x && y`, `n << 2`     | `AST_BINARY_EXPR`      |
| 一元运算   | `+x`, `-y`, `!flag`, `~mask`    | `AST_UNARY_EXPR`       |
| 条件运算   | `x > 0 ? a : b`                 | `AST_CONDITIONAL_EXPR` |
| 赋值       | `x = 10`, `y += 5`              | `AST_ASSIGN_EXPR`      |
| 成员访问   | `obj.prop`, `arr[0]`            | `AST_MEMBER_EXPR`      |
| 函数调用   | `foo(a, b)`                     | `AST_CALL_EXPR`        |
| 数组字面量 | `[1, 2, 3]`                     | `AST_ARRAY_EXPR`       |
| 对象字面量 | `{ key: value }`                | `AST_OBJECT_EXPR`      |
| 逗号表达式 | `a = 1, b = 2, c = 3`           | `AST_SEQUENCE_EXPR`    |

> 扩展表达式：`new` 调用链、模板字符串/Tagged Template、解构赋值/绑定、默认参数、`...spread`/`rest`、`function*`/`yield*`、`await`、箭头函数、`class` 表达式、`import()`、计算属性键等都可被 `parser.y` 正确解析。

#### 运算符优先级（从低到高）

```text
逗号            ,
赋值            = += -= *= /= %= &= |= ^= <<= >>= >>>=
条件            ? :
逻辑或          ||
逻辑与          &&
位或            |
位异或          ^
位与            &
相等            == != === !==
关系            < > <= >= in instanceof
位移            << >> >>>
加减            + -
乘除模          * / %
一元            + - ! ~ typeof delete void
后缀            ++ --
成员访问/调用   . [] ()
```

### 自动分号插入 (ASI)

#### 触发条件

根据 ECMAScript 5.1 规范 11.9 节，ASI 在以下三种情况下触发：

1. **换行触发**

   - 上一个 Token 可以合法结束语句
   - 当前有换行符（`lexer->has_newline == true`）
   - 继续解析会导致语法错误

   **示例**：

   ```javascript
   var a = 1;
   var b = 2; // 等价于 var a = 1; var b = 2;
   ```

2. **文件结束（EOF）**

   - 输入流结束
   - 最后一个 Token 可以结束语句

   **示例**：

   ```javascript
   var x = 10; // 等价于 var x = 10;
   ```

3. **受限产生式**

   - `return`, `break`, `continue`, `throw` 后遇到换行、`}` 或 EOF
   - 必须强制插入分号

   **示例**：

   ```javascript
   return;
   42; // 等价于 return; 42;
   ```

#### 实现机制

ASI 逻辑在 `parser_lex_adapter.c` 中实现，核心数据结构：

- `g_last_token`：记录上一个 Token
- `g_last_token_closed_control`：标记是否为控制语句头的 `)`
- `g_paren_depth`：括号深度
- `g_control_stack[]`：控制语句栈
- `g_pending`：缓存下一个真实 Token

**关键函数**：

```c
static bool should_insert_semicolon(
    int last_token,
    bool last_closed_control,
    int next_token,
    bool newline_before,
    bool is_eof
);
```

#### ASI 测试用例

| 测试文件                   | 场景                   |
| -------------------------- | ---------------------- |
| `test/test_asi_basic.js`   | 基础换行触发、`a\n++b` |
| `test/test_asi_return.js`  | `return` 受限产生式    |
| `test/test_asi_control.js` | `if`/`else` 不误插分号 |

### AST（抽象语法树）

#### 节点类型

```c
typedef enum {
    AST_PROGRAM,           // 程序根节点
    AST_VAR_DECL,          // 变量声明
    AST_FUNCTION,          // 函数声明
    AST_BLOCK_STMT,        // 块语句
    AST_IF_STMT,           // if 语句
    AST_FOR_STMT,          // for 循环
    AST_WHILE_STMT,        // while 循环
    AST_DO_WHILE_STMT,     // do-while 循环
    AST_SWITCH_STMT,       // switch 语句
    AST_TRY_STMT,          // try-catch-finally
    AST_THROW_STMT,        // throw 语句
    AST_WITH_STMT,         // with 语句
    AST_LABELED_STMT,      // 标签语句
    AST_RETURN_STMT,       // return 语句
    AST_BREAK_STMT,        // break 语句
    AST_CONTINUE_STMT,     // continue 语句
    AST_EXPR_STMT,         // 表达式语句
    AST_BINARY_EXPR,       // 二元表达式
    AST_UNARY_EXPR,        // 一元表达式
    AST_ASSIGN_EXPR,       // 赋值表达式
    AST_CONDITIONAL_EXPR,  // 条件表达式
    AST_CALL_EXPR,         // 函数调用
    AST_MEMBER_EXPR,       // 成员访问
    AST_ARRAY_EXPR,        // 数组字面量
    AST_OBJECT_EXPR,       // 对象字面量
    AST_SEQUENCE_EXPR,     // 逗号表达式
    AST_IDENTIFIER,        // 标识符
    AST_LITERAL,           // 字面量
    // ... 更多节点类型
} ASTNodeType;
```

#### AST 操作

```c
// 构造节点
ASTNode* ast_make_program(ASTList* body);
ASTNode* ast_make_binary(const char* op, ASTNode* left, ASTNode* right);
ASTNode* ast_make_identifier(const char* name);

// 打印 AST（缩进输出）
void ast_print(ASTNode* node, int indent);

// 遍历 AST
typedef void (*ASTVisitor)(ASTNode* node, void* ctx);
void ast_traverse(ASTNode* node, ASTVisitor visit, void* ctx);

// 释放 AST
void ast_free(ASTNode* node);
```

#### 使用示例

```bash
# 查看 AST 结构
.\js_parser.exe --dump-ast test\test_basic.js
```

**输出示例**：

```text
Program
  VariableDeclaration (var)
    Declarator
      name: "x"
      init: Literal(10)
  IfStatement
    test: BinaryExpression(>)
      left: Identifier(x)
      right: Literal(0)
    consequent: BlockStatement
      ExpressionStatement
        CallExpression
          callee: MemberExpression
            object: Identifier(console)
            property: Identifier(log)
          arguments:
            Literal("positive")
```

---

## 测试体系

### 测试覆盖矩阵

| 测试文件                          | 测试内容                                    | 状态     |
| --------------------------------- | ------------------------------------------- | -------- |
| `test_basic.js`                   | 综合基本语法                                | 通过     |
| `test_simple.js`                  | 简单函数与表达式                            | 通过     |
| `test_functions.js`               | 函数嵌套、闭包                              | 通过     |
| `test_for_loops.js`               | 多种 for 循环                               | 通过     |
| `test_literals.js`                | 对象/数组字面量                             | 通过     |
| `test_asi_basic.js`               | ASI 基础场景                                | 通过     |
| `test_asi_return.js`              | ASI 受限产生式                              | 通过     |
| `test_asi_control.js`             | ASI 与控制语句                              | 通过     |
| `test_while.js`                   | while/do-while + 标签                       | 通过     |
| `test_switch.js`                  | switch-case/default                         | 通过     |
| `test_try.js`                     | try-catch-finally + with                    | 通过     |
| `test_operators.js`               | 运算符优先级                                | 通过     |
| `test_error_missing_semicolon.js` | 缺少分号错误                                | 通过     |
| `test_error_object.js`            | 对象缺冒号错误                              | 通过     |
| `test_error_unclosed_block.js`    | 缺少 `}` 错误                               | 通过     |
| `test_error_invalid_for.js`       | for 缺 `)` 错误                             | 通过     |
| `es6_stage1/*.js`                 | 解构绑定/默认值/`catch` 绑定                | 通过     |
| `es6_stage2/*.js`                 | 箭头函数、参数系统、受限换行                | 通过     |
| `es6_stage3/*.js`                 | 模板字符串与 tagged template                | 通过     |
| `es6_stage4/*.js`                 | `class`、增强对象字面量                     | 通过     |
| `es6_stage5/*.js`                 | `for-of`、`function*`/`yield*`、spread/rest | 通过     |
| `JavaScript_Datasets/goodjs`      | 真实压缩脚本（期望解析成功）                | 通过     |
| `JavaScript_Datasets/badjs`       | 真实错误集合（用于验证诊断）                | 预期失败 |

> 运行 `make test …`、`make test-parse` 或 `.uild.bat test <path>` 时，会把所有语法错误写入 `build/parser_error_locations.log`（`文件:行:列:错误`）。`build/test_failures.log` 记录完整 stdout/stderr，便于与 Node/V8 行为做 diff。

### 运行测试

#### 完整测试套件

```bash
# Windows
.\make test-parse

# Linux/macOS
make test-parse
```

#### 单个测试

```bash
# 测试正确的语法
.\js_parser.exe test\test_basic.js

# 测试错误检测
.\js_parser.exe test\test_error_object.js
```

### 测试结果

**成功输出**：

```text
Parsing successful! Input file: test\test_basic.js
```

**错误输出**：

```text
Syntax error: syntax error, unexpected STRING, expecting ':'
Parsing failed. Input file: test\test_error_object.js
```

---

## 开发指南

### 编译警告说明

#### 1. re2c sentinel 警告

```text
lexer.re:82:20: warning: sentinel symbol 0 occurs in the middle of the rule
```

**影响**：无影响，仅是优化建议  
**解决**：可添加 `re2c:sentinel` 配置（可选）

#### 2. Bison 冲突警告

```text
parser.y: 警告: 3 项偏移/归约冲突 [-Wconflicts-sr]
```

**影响**：无影响，Bison 使用默认规则解决  
**原因**：表达式语法的自然歧义（如 if-else 的悬挂 else）  
**解决**：可添加 `%expect 3` 指令消除警告（可选）

#### 3. 未使用变量警告

```text
lexer.re:89:25: warning: unused variable 'comment_start'
```

**影响**：无影响  
**解决**：删除未使用的变量或添加使用逻辑

### 添加新语法特性

#### 步骤 1：更新词法分析器（如需要）

编辑 `lexer.re`，添加新的 Token 类型：

```c
// 在 token.h 中添加新 Token
TOK_NEW_KEYWORD,

// 在 lexer.re 中添加规则
"newkeyword" { return make_token(TOK_NEW_KEYWORD, ...); }
```

#### 步骤 2：更新语法分析器

编辑 `parser.y`，添加新的语法规则：

```yacc
%token NEW_KEYWORD

%%

new_statement
    : NEW_KEYWORD '(' expr ')' stmt
        { $$ = ast_make_new_stmt($3, $5); }
    ;
```

#### 步骤 3：更新 AST

编辑 `ast.h` 和 `ast.c`：

```c
// ast.h
typedef enum {
    // ...
    AST_NEW_STMT,
} ASTNodeType;

ASTNode* ast_make_new_stmt(ASTNode* test, ASTNode* body);

// ast.c
ASTNode* ast_make_new_stmt(ASTNode* test, ASTNode* body) {
    ASTNode* node = ast_alloc_node(AST_NEW_STMT);
    node->new_stmt.test = test;
    node->new_stmt.body = body;
    return node;
}
```

#### 步骤 4：添加测试用例

创建 `test/test_new_feature.js`：

```javascript
// 测试新特性
newkeyword (x > 0) {
    console.log("new feature");
}
```

#### 步骤 5：更新构建脚本

编辑 `make` 或 `Makefile`，将新测试文件加入 `test-parse` 目标。

### 调试技巧

#### 1. 查看 Token 流

```bash
.\js_lexer.exe your_file.js
```

用于确认词法分析是否正确识别 Token。

#### 2. 查看 AST 结构

```bash
.\js_parser.exe --dump-ast your_file.js
```

用于验证语法树结构是否符合预期。

#### 3. 使用 Bison 详细错误

`parser.y` 已启用 `%define parse.error verbose`，会输出详细错误信息。

#### 4. 启用调试模式

编辑 `parser_main.c`，取消注释以下行：

```c
// yydebug = 1;  // 启用 Bison 调试输出
```

重新编译后，解析过程会输出每一步的状态转移。

---

## 常见问题

### Q: 为什么需要两个可执行程序？

**A**: 双可执行程序设计便于分层调试：

- `js_lexer.exe`：输出 Token 流，方便查看词法分析结果
- `js_parser.exe`：专注语法验证和 AST 生成

### Q: 构建时的警告是否需要修复？

**A**: 不是必须的。这些警告不影响程序功能，属于优化建议。

### Q: 如何添加新的测试用例？

**A**: 在 `test/` 目录创建新的 `.js` 文件，然后运行：

```bash
.\js_parser.exe test\your_test.js
```

如需加入自动测试，编辑 `make` 或 `Makefile` 的 `test-parse` 目标。

### Q: 为什么使用 re2c 而不是 Flex？

**A**: JavaScript 标识符基于 Unicode 定义（ECMAScript 规范），re2c 原生支持 Unicode 字符类，而 Flex 不支持。

### Q: 当前是否支持 ES6+ 语法？

**A**: 已支持 ES2015 ~ ES2017 的主流语法（模块、类、解构、模板字符串、`function*`/`yield*`、`async function`/`await`、箭头函数、`for-of` 等），但 ES2020+ 的可选链、空值合并、装饰器、顶层 `await` 等仍未落地。若数据集中的文件依赖未实现特性，请先参考 `docs/es6_limitations.md` 再决定是否扩展语法。

### Q: 如何处理路径中的空格？

**A**: Windows 用户需确保 `make` 中的路径用引号包裹：

```batch
set "GCC=C:\Program Files (x86)\mingw64\bin\gcc.exe"
```

### Q: 编译时提示找不到 `parser.h` 怎么办？

**A**: 先执行一次构建生成头文件：

```bash
.\make parser  # Windows
make parser         # Linux/macOS
```

### Q: 如何清理生成文件？

**A**: 使用清理命令：

```bash
.\make clean  # Windows
make clean         # Linux/macOS
```

### Q: 支持哪些数字格式？

**A**: 支持以下格式：

- 十进制整数：`123`
- 十进制浮点数：`3.14`
- 科学计数法：`1e5`, `2.5e-3`
- 十六进制：`0xFF`, `0xABCD`

### Q: 如何贡献代码？

**A**: 参考以下步骤：

1. Fork 项目仓库
2. 创建功能分支：`git checkout -b feature/new-feature`
3. 提交更改：`git commit -am 'Add new feature'`
4. 推送分支：`git push origin feature/new-feature`
5. 提交 Pull Request

---

## 参考资料

### 规范文档

- [ECMAScript 5.1 规范](https://262.ecma-international.org/5.1/)
- [ASI 规则详解（11.9 节）](https://262.ecma-international.org/5.1/#sec-11.9)

### 工具文档

- [re2c 官方手册](https://re2c.org/manual/manual_c.html)
- [GNU Bison 手册](https://www.gnu.org/software/bison/manual/)
- [GCC 文档](https://gcc.gnu.org/onlinedocs/)

### 参考项目

- [flex-bison-examples](https://github.com/sunxfancy/flex-bison-examples)
- [Esprima (JavaScript 解析器)](https://esprima.org/)
- [Acorn (轻量级 JS 解析器)](https://github.com/acornjs/acorn)

### 编译原理书籍

- 《编译原理》（龙书）- Alfred V. Aho 等著
- 《现代编译原理》- Andrew W. Appel 著
- 《程序设计语言实现模式》- Terence Parr 著

### 项目文档

- [BUILD.md](docs/BUILD.md) - 构建与调试指南
- [TEST_REPORT.md](docs/TEST_REPORT.md) - 测试报告
- [asi_implementation.md](docs/asi_implementation.md) - ASI 实现细节
- [parser.md](docs/parser.md) - 语法分析说明
- [lex.md](docs/lex.md) - 词法分析说明
- [todo.md](docs/todo.md) - 开发任务清单

---

## 附录

### 项目统计

| 指标         | 数值  |
| ------------ | ----- |
| 总代码行数   | ~2500 |
| 测试文件数量 | 16    |
| 测试通过率   | 100%  |
| 支持的关键字 | 27    |
| 支持的运算符 | 73+   |
| AST 节点类型 | 30+   |
| 文档总页数   | 50+   |

### 贡献者

- [Stardreama](https://github.com/Stardreama)
- [Limpid-8818](https://github.com/Limpid-8818)
- [FanZDStar](https://github.com/FanZDStar)

### 许可证

本项目采用 MIT 许可证。

### 更新日志

- **2025-11-11**: 创建完整项目指南
- **2025-11-10**: 完成 ASI、AST、语句扩展、运算符扩展
- **2025-11-09**: 完成基础语法分析器
- **2025-11-08**: 完成词法分析器

---

**项目地址**: https://github.com/Stardreama/js_compiler_by_c  
**最后更新**: 2025 年 11 月 11 日
